[合集 \- C\#(90\)](https://github.com)[1\.使用C\#将几个Excel文件合并去重分类2023\-11\-15](https://github.com/mingupupu/p/17833301.html)[2\.C\#使用SqlSugar操作MySQL数据库实现简单的增删改查2023\-11\-16](https://github.com/mingupupu/p/17837125.html)[3\.C\#中的类和继承2023\-11\-17](https://github.com/mingupupu/p/17837924.html)[4\.C\#中的virtual和override关键字2023\-11\-17](https://github.com/mingupupu/p/17837993.html)[5\.C\#中的属性2023\-11\-20](https://github.com/mingupupu/p/17844001.html)[6\.C\#winform中使用SQLite数据库2023\-11\-23](https://github.com/mingupupu/p/17852402.html)[7\.C\#简化工作之实现网页爬虫获取数据2023\-11\-27](https://github.com/mingupupu/p/17860491.html)[8\.C\#中的委托（一）2023\-11\-29](https://github.com/mingupupu/p/17864012.html)[9\.C\#中的ref关键字2023\-11\-29](https://github.com/mingupupu/p/17864054.html)[10\.C\#中out关键字2023\-11\-29](https://github.com/mingupupu/p/17864071.html)[11\.C\#中内置的泛型委托Func与Action2023\-12\-04](https://github.com/mingupupu/p/17876044.html)[12\.在winform blazor hybrid中绘图2023\-12\-13](https://github.com/mingupupu/p/17900024.html)[13\.使用C\#如何监控选定文件夹中文件的变动情况？2023\-12\-28](https://github.com/mingupupu/p/17933098.html)[14\.C\#设计模式之策略模式01\-02](https://github.com/mingupupu/p/17940231)[15\.由浅入深理解C\#中的事件01\-04](https://github.com/mingupupu/p/17946032)[16\.C\#设计模式之观察者模式01\-04](https://github.com/mingupupu/p/17946033)[17\.C\#设计模式之单例模式01\-08](https://github.com/mingupupu/p/17952872)[18\.C\#基于ScottPlot进行可视化01\-13](https://github.com/mingupupu/p/17963079)[19\.C\#使用MiniExcel导入导出数据到Excel/CSV文件02\-10](https://github.com/mingupupu/p/18013077)[20\.winform实现最小化至系统托盘02\-19](https://github.com/mingupupu/p/18022142)[21\.C\#使用Bogus生成测试数据02\-27](https://github.com/mingupupu/p/18036409)[22\.SemanticKernel如何基于自有数据聊天03\-05](https://github.com/mingupupu/p/18054386)[23\.在winform中如何嵌入第三方软件窗体✨03\-07](https://github.com/mingupupu/p/18058334)[24\.在winform中如何实现双向数据绑定？03\-18](https://github.com/mingupupu/p/18080974)[25\.自己动手做一个批量doc转换为docx文件的小工具03\-20](https://github.com/mingupupu/p/18085637)[26\.WPF中动画教程（DoubleAnimation的基本使用）04\-01](https://github.com/mingupupu/p/18108029)[27\.WPF动画教程（PointAnimationUsingPath的使用）04\-03](https://github.com/mingupupu/p/18113095)[28\.C\#使用PaddleOCR进行图片文字识别✨04\-09](https://github.com/mingupupu/p/18124485)[29\.WPF基础：在Canvas上绘制图形04\-16](https://github.com/mingupupu/p/18137691)[30\.WPF/C\#：让绘制的图形可以被选中并将信息显示在ListBox中04\-19](https://github.com/mingupupu/p/18145295)[31\.使用归一化盒过滤器对图像进行平滑处理04\-20](https://github.com/mingupupu/p/18147819)[32\.WPF/C\#：如何显示具有层级关系的数据04\-22](https://github.com/mingupupu/p/18150708)[33\.将彩色图转化为灰度图及其原理介绍04\-23](https://github.com/mingupupu/p/18153025)[34\.WPF/C\#：ProgressBar的基本使用05\-08](https://github.com/mingupupu/p/18179009)[35\.在VB.NET项目中使用C\#编写的代码05\-21](https://github.com/mingupupu/p/18204780)[36\.WPF/C\#：理解与实现WPF中的MVVM模式05\-28](https://github.com/mingupupu/p/18218027)[37\.SemanticKernel：添加插件06\-06](https://github.com/mingupupu/p/18234563)[38\.Avalonia：一个.NET跨平台UI框架06\-10](https://github.com/mingupupu/p/18241078)[39\.WPF/C\#：异常处理06\-12](https://github.com/mingupupu/p/18243650)[40\.WPF/C\#：程序关闭的三种模式06\-12](https://github.com/mingupupu/p/18243656)[41\.wpfui：一个开源免费具有现代化设计趋势的WPF控件库06\-13](https://github.com/mingupupu/p/18245521)[42\.WPF/C\#：如何将数据分组显示06\-17](https://github.com/mingupupu/p/18252701)[43\.WPF/C\#:更改界面的样式06\-17](https://github.com/mingupupu/p/18252711)[44\.LiveCharts2：简单灵活交互式且功能强大的.NET图表库06\-18](https://github.com/mingupupu/p/18253741)[45\.WPF/C\#：显示分组数据的两种方式06\-19](https://github.com/mingupupu/p/18256035)[46\.WPF/C\#：在DataGrid中显示选择框06\-20](https://github.com/mingupupu/p/18258249)[47\.WPF/C\#：数据绑定到方法06\-21](https://github.com/mingupupu/p/18260193)[48\.WPF/C\#：BusinessLayerValidation06\-25](https://github.com/mingupupu/p/18267222)[49\.WPF/C\#：如何实现拖拉元素06\-27](https://github.com/mingupupu/p/18270547)[50\.WPF在.NET9中的重大更新：Windows 11 主题07\-01](https://github.com/mingupupu/p/18277446)[51\.ONNX Runtime入门示例：在C\#中使用ResNet50v2进行图像识别07\-02](https://github.com/mingupupu/p/18279640):[豆荚加速器官网PodHub](https://doujiaa.com)[52\.动手学Avalonia：基于SemanticKernel与硅基流动构建AI聊天与翻译工具07\-03](https://github.com/mingupupu/p/18281546)[53\.Avalonia应用在基于Linux的国产操作deepin上运行07\-04](https://github.com/mingupupu/p/18283277)[54\.如何让其他模型也能在SemanticKernel中调用本地函数07\-05](https://github.com/mingupupu/p/18286405)[55\.大语言模型的应用探索—AI Agent初探！07\-08](https://github.com/mingupupu/p/18290420)[56\.动手学Avalonia：基于硅基流动构建一个文生图应用（一）07\-10](https://github.com/mingupupu/p/18294916)[57\.WPF/C\#：在WPF中如何实现依赖注入07\-11](https://github.com/mingupupu/p/18295546)[58\.ScreenToGif：一款开源免费且好用的录屏转Gif软件07\-12](https://github.com/mingupupu/p/18298492)[59\.WPF/C\#：实现导航功能07\-18](https://github.com/mingupupu/p/18309608)[60\.关于学习.NET的历程回顾与今后的探索实践方向07\-24](https://github.com/mingupupu/p/18320722)[61\.入门Vue\+.NET 8 Web Api记录（一）07\-25](https://github.com/mingupupu/p/18322881)[62\.SemanticKernel/C\#：检索增强生成(RAG)简易实践08\-01](https://github.com/mingupupu/p/18336055)[63\.SemanticKernel/C\#：使用Ollama中的对话模型与嵌入模型用于本地离线场景08\-02](https://github.com/mingupupu/p/18339290)[64\.SemanticKernel/C\#：实现接口，接入本地嵌入模型08\-06](https://github.com/mingupupu/p/18344517)[65\.EF Core连接PostgreSQL数据库08\-07](https://github.com/mingupupu/p/18347247)[66\.基于SiliconCloud快速体验GraphRag.Net08\-08](https://github.com/mingupupu/p/18349566)[67\.AvaloniaChat：一个基于大语言模型用于翻译的简单应用08\-16](https://github.com/mingupupu/p/18362777)[68\.最佳实践：在AvaloniaChat中接入SiliconCloud08\-16](https://github.com/mingupupu/p/18362781)[69\.AvaloniaChat—从源码构建指南08\-18](https://github.com/mingupupu/p/18365633)[70\.SimpleRAG：基于WPF与Semantic Kernel实现的一个简单的RAG应用08\-19](https://github.com/mingupupu/p/18367726)[71\.Semantic Kernel/C\#：接入智谱AI的两种方式08\-21](https://github.com/mingupupu/p/18370917)[72\.AvaloniaChat\-v0\.0\.2：兼容智谱AI 快速使用指南08\-21](https://github.com/mingupupu/p/18370914)[73\.使用SiliconCloud快速体验SimpleRAG（手把手教程）08\-22](https://github.com/mingupupu/p/18373908)[74\.使用Ollama本地离线体验SimpleRAG（手把手教程）08\-23](https://github.com/mingupupu/p/18375424)[75\.Semantic Kernel/C\#：一种通用的Function Calling方法，文末附经测试可用的大模型08\-29](https://github.com/mingupupu/p/18385798)[76\.在SimpleRAG中使用SiliconCloud快速测试Function Calling08\-29](https://github.com/mingupupu/p/18385799)[77\.SimpleTranslationAIAgent：基于C\#与LLM的翻译AI Agent08\-31](https://github.com/mingupupu/p/18390206)[78\.SimpleTranslationAIAgent借助SiliconCloud API 构建自己的专属翻译助手08\-31](https://github.com/mingupupu/p/18390207)[79\.SimpleAISearch：C\# \+ DuckDuckGo 实现简单的AI搜索09\-20](https://github.com/mingupupu/p/18422209)[80\.SimpleAIAgent：使用免费的glm\-4\-flash即可开始构建简单的AI Agent应用09\-25](https://github.com/mingupupu/p/18431071)[81\.SimpleRAG\-v1\.0\.3：增加文件对话功能09\-26](https://github.com/mingupupu/p/18433464)[82\.如何自己动手实现一个图片解答小助手10\-09](https://github.com/mingupupu/p/18453894)[83\.AvaloniaTCP\-v1\.0\.0：学习使用Avalonia/C\#进行TCP通讯的一个简单Demo10\-14](https://github.com/mingupupu/p/18463874)[84\.Microsoft.Extensions.AI 初探11\-20](https://github.com/mingupupu/p/18556342)[85\.TesseractOCR\-GUI：基于WPF/C\#构建TesseractOCR简单易用的用户界面12\-07](https://github.com/mingupupu/p/18592170)[86\.VLM\-OCR\-Demo：一个使用VLM用于OCR任务的示例12\-09](https://github.com/mingupupu/p/18594592)[87\.C\#调用Python脚本的方式（一），以PaddleOCR\-GUI为例12\-13](https://github.com/mingupupu/p/18605737)[88\.C\#调用Python代码的方式（二），以PaddleOCR\-GUI为例12\-17](https://github.com/mingupupu/p/18612101)89\.C\#使用Tesseract C\+\+ API过程记录12\-27[90\.C\#调用C\+\+代码，以OpenCV为例12\-27](https://github.com/mingupupu/p/18636616)收起
## Tesseract


Tesseract 是一个开源的光学字符识别（OCR）引擎，最初由 Hewlett\-Packard（惠普）实验室开发，后来由 Google 收购并继续维护和开源贡献。Tesseract 可以识别多种语言的文字，广泛应用于将图片或扫描文档中的文本内容转换成可编辑的文本格式。随着深度学习技术的发展，Tesseract 也整合了基于深度神经网络的 OCR 模型，提升其识别准确率，特别是对于复杂排版和手写体的识别效果有所改善。


Tesseract 适合开发人员和研究人员使用，可以嵌入到各种应用中，比如文档数字化、图像处理软件、内容管理系统等。它支持命令行操作，也提供了丰富的 API 接口，支持 C\+\+、Python、Java、Node.js 等多种编程语言，便于集成和调用。Tesseract 的核心功能包括文本检测、字符识别和后处理纠错，能够处理多种图像输入格式，输出包括纯文本、HOCR（HTML \+ OCR）格式、PDF 等多种格式。Tesseract 的高灵活性和强大的识别能力使其成为 OCR 领域中非常受欢迎的工具之一。


GitHub地址：[https://github.com/tesseract\-ocr/tesseract](https://github.com)


![image-20241227152937200](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729631-1101186648.png)


Tesseract提供了丰富的 API 接口，支持 C\+\+、Python、Java、Node.js 等多种编程语言，没有C\#的，实际上已经有大佬做了C\#的封装了，并提供了一个示例项目，需要只是简单使用一下，用这个大佬的就很方便了。


感兴趣的可以瞧瞧：


项目GitHub地址：[https://github.com/charlesw/tesseract](https://github.com)


![image-20241227153302569](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729612-381087639.png)


示例GitHub地址：[https://github.com/charlesw/tesseract\-samples](https://github.com)


![image-20241227153437445](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729643-1938570573.png)


但这不是我们今天的主题，现在还处于学习阶段，能直接使用大佬的库确实很方便，但是如果自己能够知道大佬是怎么实现的，那不是也很酷吗？


实现的方式与大佬项目的方式是类似的，如下所示：


![image-20241227153822517](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729650-85923879.png)


需要依赖leptonica\-1\.82\.0\.dll与tesseract50\.dll，然后通过DllImport导入其中的C\+\+函数。


已经有现成的库了为什么不直接使用呢？


第一，项目中可能只需要用到Tesseract的几个C\+\+ API而已，直接引用一大堆东西没有必要。第二，学习阶段，以自己学习掌握技能为主，自己先掌握了这项技能，然后偷懒了直接使用大佬的库也不迟。


## Windows编译Tesseract


首先我们需要先在Windows上编译Tesseract，官方文档有一些介绍，文档地址：[https://tesseract\-ocr.github.io/tessdoc/Compiling.html。](https://github.com)


查看文档之后，我使用这种方式：


![image-20241227154722530](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729599-1717563373.png)


先来简单介绍一下vcpkg。


**vcpkg**


vcpkg是一个用来管理C\+\+库的跨平台包管理工具，由微软开发并维护，旨在帮助开发者简化第三方库的集成和使用过程。vcpkg通过提供预编译的二进制包和源代码，使开发者能够在Windows、Linux和macOS等操作系统上轻松安装和管理C\+\+库。它支持多种编译器，包括Visual Studio、GCC和Clang。vcpkg的使用非常简单，只需要下载并安装，然后通过命令行工具指定要安装的库名，vcpkg会自动下载、编译并安装所需的库及其依赖项。此外，vcpkg还具有版本控制功能，能够方便地切换库的不同版本。它对于提升开发效率、保持项目的一致性以及解决跨平台开发中的库兼容性问题非常有帮助。许多开源项目和商业软件都选择使用vcpkg来管理和分发依赖库。


**使用vcpkg安装Tesseract**



```
git clone https://github.com/microsoft/vcpkg.git

```


```
cd vcpkg; .\bootstrap-vcpkg.bat

```


```
vcpkg install tesseract:x64-windows

```

安装完成：


![image-20241226105928367](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194729640-169509381.png)



```
vcpkg integrate install

```

![image-20241226110526085](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730015-74887334.png)


为这个 vcpkg 根目录应用了全局用户集成。 CMake 项目应使用："\-DCMAKE\_TOOLCHAIN\_FILE\=D:/Learning/vcpkg/scripts/buildsystems/vcpkg.cmake"


现在所有 MSBuild C\+\+ 项目都可以 \#include 任何已安装的库。链接将会自动处理。安装新库后，它们将立即可用。



```
vcpkg list

```

![image-20241226110859781](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730031-1360549776.png)


**新建一个C\+\+项目使用Tesseract C\+\+ API**


我写了两个简单的函数用于测试。


头文件：



```
#pragma once
extern "C" __declspec(dllexport) char* getChineseText(const char* imagePath);
extern "C" __declspec(dllexport) char* getEnglishText(const char* imagePath);
extern "C" __declspec(dllexport) void freeMemory(char* ptr);

```

源文件：



```
#include 
#include 
#include "test.h"
#include 

void windows_cmd_support_utf8(void)
{
   system("chcp 65001 & cls"); //cls 用来清除 chcp 的输出
}

char* getEnglishText(const char* imgPath) {
    tesseract::TessBaseAPI* api = new tesseract::TessBaseAPI();
    if (api->Init(NULL, "eng")) {
        fprintf(stderr, "Could not initialize tesseract.\n");
        delete api;
        return nullptr;
    }

    Pix* image = pixRead(imgPath);
    if (!image) {
        fprintf(stderr, "Could not read image file.\n");
        api->End();
        delete api;
        return nullptr;
    }

    api->SetImage(image);
    char* outText = api->GetUTF8Text();
    if (!outText) {
        fprintf(stderr, "OCR failed.\n");
        api->End();
        pixDestroy(&image);
        delete api;
        return nullptr;
    }
  

    api->Clear();
    api->End();
    delete api;
    pixDestroy(&image);

    return outText;
}

char* getChineseText(const char* imgPath) {
    tesseract::TessBaseAPI* api = new tesseract::TessBaseAPI();
    if (api->Init(NULL, "chi_sim")) {
        fprintf(stderr, "Could not initialize tesseract.\n");
        delete api;
        return nullptr;
    }

    Pix* image = pixRead(imgPath);
    if (!image) {
        fprintf(stderr, "Could not read image file.\n");
        api->End();
        delete api;
        return nullptr;
    }

    api->SetImage(image);
    char* outText = api->GetUTF8Text();
    if (!outText) {
        fprintf(stderr, "OCR failed.\n");
        api->End();
        pixDestroy(&image);
        delete api;
        return nullptr;
    }


    api->Clear();
    api->End();
    delete api;
    pixDestroy(&image);

    return outText;
}

void freeMemory(char* ptr) {
    delete[] ptr;
}

int main()
{ 
    const char* imgPath = "D:\\SemanticKernel-Test2.png";  // 替换为你的图像文件路径

    const char* imgPath2 = "D:\\test666.png";  // 替换为你的图像文件路径

    // 第一次调用
    char* result1 = getChineseText(imgPath);

    windows_cmd_support_utf8();

    std::cout << "OCR Result 1: " << result1 << std::endl;

    // 第二次调用
    char* result2 = getChineseText(imgPath2);
    std::cout << "OCR Result 2: " << result2 << std::endl;

    // 释放内存
    //freeMemory(result1);
    //freeMemory(result2);
    return 0;  // 程序正常结束

}

```

**注意📍📍📍**


先将项目配置成X64:


![image-20241227160709604](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730041-1173601267.png)


现在运行项目，会出现一个错误，因为并没有包含tessdata。


`tessdata` 是 Tesseract OCR 引擎使用的一种数据文件格式，用于存储语言模型和字符识别数据。Tesseract 通过加载这些数据文件来实现对不同语言文字的识别。每个语言都有一套对应的 `tessdata` 文件，通常命名为 `lang.traineddata`，其中 `lang` 是语言的缩写（例如，`eng` 表示英语，`chi_sim` 表示简体中文）。


tessdata的GitHub地址：[https://github.com/tesseract\-ocr/tessdata](https://github.com)


![image-20241227185027622](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730017-1976357499.png)


也可以看我后面分享的GitHub，一般只要中英文就可以了，如下所示：


![image-20241227185504978](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730076-1450207605.png)


将tessdata文件夹放在x64的Debug目录下即可。


先测试中文识别效果：


测试图片1


![](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730091-251181949.png)


测试图片2


![](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730001-2107054339.png)


查看效果：


![image-20241227155928432](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730081-1651063265.png)


**注意📍📍📍**


如果不加上windows\_cmd\_support\_utf8();


就会出现乱码，如下所示：


![image-20241227160300511](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730125-333085352.png)


并不是Tesseract识别中文效果不好，只是控制台默认没支持utf\-8罢了。


再来测试一下英文：


测试图片1


![](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730052-1079384972.png)


测试图片2


![](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730110-330088012.png)


效果如下所示：


![image-20241227190017513](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730148-1035987125.png)


**生成DLL**


测试没有问题之后，现在需要生成DLL文件。


右键项目，点击属性，设置配置类型为DLL：


![image-20241227190254191](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730083-453268042.png)


生成解决方案之后，如下所示：


![image-20241227190504150](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730033-2080829928.png)


这里需要搞清楚的是为什么头文件不用std::string而是char\*呢？



```
#pragma once
extern "C" __declspec(dllexport) char* getChineseText(const char* imagePath);
extern "C" __declspec(dllexport) char* getEnglishText(const char* imagePath);
extern "C" __declspec(dllexport) void freeMemory(char* ptr);

```

* **`extern "C"`**：这告诉编译器这些函数应该按照C语言的方式进行链接，而不是C\+\+的方式。这样可以确保这些函数在C语言中也可以被正确调用。
* 简单的说std::string不是C语言风格的，所以不行。


## 在C\#项目中调用C\+\+ DLL


新建一个C\#控制台项目用于测试。


测试代码如下：



```
using System.Runtime.InteropServices;

class Program
{
    [DllImport("TesseractApiTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern IntPtr getEnglishText(string imagePath);

    [DllImport("TesseractApiTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern IntPtr getChineseText(string imagePath);


    static void Main()
    {
        

        string imagePath = @"D:\SemanticKernel-Test2.png";

        // 调用 DLL 中的函数
        IntPtr resultPtr = getChineseText(imagePath);
        if (resultPtr == IntPtr.Zero)
        {
            return;
        }

        string? result = Marshal.PtrToStringUTF8(resultPtr);
        return; ;

    }
}

```

将项目设置成X64平台，将C\+\+项目的所有输出文件，复制到X64的输出目录这里，如下所示：


![image-20241227191524217](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730116-2074493614.png)


为了避免太混乱，本来想新建一个Libs文件夹，在放这些文件，在设置为嵌入的资源与如果较新就复制，但是就调用不了了，暂时没有解决，只能这样一堆放在这里了。


效果如下：


![image-20241227191730397](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730079-975920089.png)


这里需要注意一下，为什么是



```
  [DllImport("TesseractApiTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
  public static extern IntPtr getEnglishText(string imagePath);

```

而不是



```
  [DllImport("TesseractApiTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
  public static extern string getEnglishText(string imagePath);

```

在C\#中直接使用 `string` 作为返回类型并不适用于从C\+\+导出的函数，尤其是当该函数返回的是一个 `char*` 类型的指针时。原因在于  `char*` 是一个指向C风格字符串的指针，而C\#中的 `string` 类型与C风格字符串并不直接兼容。C\#的 `string` 类型是一个托管的字符串对象，而  `char*` 是一个非托管的指针，直接进行转换会导致运行时错误或无法预期的行为。


使用 `IntPtr` 作为返回类型可以解决这个问题，因为 `IntPtr` 是一个可以表示非托管指针的类型。你可以通过 `Marshal` 类将 `IntPtr` 转换为C\#中的 `string`。这样可以确保你在C\#中能够正确处理C\+\+函数返回的字符串指针。


## TesseractOCR\-GUI中集成


之前跟大家分享的TesseractOCR\-GUI需要在电脑上安装Tesseract才能用，因为只是简单的对Tesseract的命令行使用做了封装，现在通过这种方法，不需要安装Tesseract也能使用了。


GitHub地址：[https://github.com/Ming\-jiayou/TesseractOCR\-GUI。](https://github.com)


![image-20241227192409247](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730131-310354925.png)


git clone到本地，然后将平台设置成X64，先生成解决方案，然后将Libs文件夹下的内容，全部复制到x64的输出目录，如下所示：


![image-20241227192607954](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730034-1492062934.png)


![image-20241227192639528](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730170-1679784172.png)


现在直接点击应该就可以使用了：


![image-20241227192803222](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730112-66324081.png)


效果如下所示：


![image-20241227193007146](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730050-801989325.png)


![](https://img2024.cnblogs.com/blog/3288240/202412/3288240-20241227194730125-1076819534.gif)


速度还是很快的，目前为止我们尝试了TesseractOCR、PaddleOCR、VLM，其中TesseractOCR我感觉是最快的。


以上就是本期的分享内容，希望对你有所帮助。


推荐阅读：


[C\#调用C\+\+代码，以OpenCV为例](https://github.com)


[C\#调用Python脚本的方式（一），以PaddleOCR\-GUI为例](https://github.com)


[C\#调用Python代码的方式（二），以PaddleOCR\-GUI为例](https://github.com)


[VLM\-OCR\-Demo：一个使用VLM用于OCR任务的示例](https://github.com)


[TesseractOCR\-GUI：基于WPF/C\#构建TesseractOCR简单易用的用户界面](https://github.com)


[使用Tesseract进行图片文字识别](https://github.com)


